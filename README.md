# Patten_java
常见的java实现的设计模式
一，设计原则：
1.找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起，（封装变化）
2.针对接口编程，而不是针对实现编程。
3.多用组合，少用继承。：用组合建立的系统具有很大的弹性，不仅可以将算法封装成类，也可以在运行时动态地改变行为。有一个比是一个更好。
4.为交互对象之间的松耦合设计而努力
5.对扩展开放，对修改关闭。（装饰者是很好的体现）
6.要依赖抽象，不要依赖具体类。这就是依赖倒置原则。它更强调的是抽象，不能让高层组件依赖低层组件，如工厂模式里的的store是高层，pizza是低层，两者都应该依赖抽象。
7.最少知识原则：只和你的密友谈话。就是说当你在设计一个系统，不管任何对象，你都要注意它所交互的类有哪些。不要让太多的类藕合在一起。
8.单一模式：一个类应该只有一个引起变化的原因。
二策略模式
定义算法族，分别封装起来，让它们之间可以互相替换，算法的变化独立于使用算法的客户。
这种模式的好处：实现不会被绑死在子类中，使用接口，可以运行时替换。


三.观察者模式
定义了对象之间的一对多依赖，这样一来，当一个对象改变时，它的所有依赖者都会收到通知并自动更新。
四，装饰模式
装饰者模式：动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
缺点：会导致出现我很多小对象，如果过度使用，会让程序变得复杂。
它用到了继承，但主要是为了使装饰者和被装饰者有相同的接口。在组合时得到新的行为，所以它主要还是依赖组合。

五，工厂模式：
1，简单工厂模式：主要是在初始化对象进行解耦合，工厂模式封装了创建对象的细节。一般是静态方法。但使用静态方法有一个缺点，就是无法通过继承来改变对象创建过程。
2.工厂模式：把创建changfen分为子类中，定义一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类。
3.抽象工厂模式：提供一个接口，用于创建或依赖对象的家族，而不需要明确指定具体类。它提供了一个原料的生产工厂，原料的生产对客户不可见。
工厂模式与抽象工厂模式的区别：工厂模式是用继承来扩展一个类，只是将创建对象留到子类中执行。抽象工厂利用对象组合，利用一个大接口来创建整个产品家族。
六，单例模式：确保一个类只有一个实例，并提供一个全局访问点。
同步一个方法可能会造成程序执行效率下降100倍。
七，适配器模式：将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。这个模式可以通过创建接口，让不兼容接口变成兼容，可以让客户实现接口解耦。使用对象组合，以修改的接口包装被适配者。简单说就是让一只鹅实现一只鸭的功能。
适配器分为类适配器和对象适配器，类适配器要多继承，在java中无法实现。
对象适配器类图：

八，外观模式：
提供一个统一接口，用来访问子系统中的一群接口，外观定义一个高层接口，让子系统更容易使用。
九，模板方法：
在一个方法中定义现代战争算法的骨架，而将一些步骤延迟到子类中，模板主法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

钩子：是一种被声明在抽象类中的方法，但只有空的或者默认的实现 。钩子的存在可以让子类有能力对算法的不同点进行挂钩，由子类自行决定 。代码如下：
public final void FinishProject(){
          searchProject();
          viewProject();
           if(canAduit()){
          aduitProject();
          }
          System. out.println( "------finish one--------");
     }
     public boolean canAduit(){
           return true;
     }
其中canAduit就是一个钩子。
十.组合模式
允许你将对象组成树形结构来表现“整体/部分”的层次结构，组合能让用户以一致方式处理保别对象和对象组合。
十一，状态模式
允许对象在内部状态改变时改变它的行为，对象看上进来好像修改了它的类。它将状态封装成独立的类，并将动作委托到代表当前状态的对象 。

十二，代理模式：为另一个对象提供一个替身或占位符以控制对这个对象的访问。
